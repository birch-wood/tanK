package net.emdal.tank

data class Graph(val query: String = "", val aliases: List<Pair<String, List<Entity>>> = emptyList()) {

  /**
   * Builds a Cypher query part for a node definition on the form:
   * ([alias]:[labels] { [properties] })
   *
   * @return A [Graph] containing the previously built query and context plus the one generated by
   * this node function.
   */
  fun <T : Node> node(
    alias: String = "",
    vararg labels: T,
    properties: T.() -> String? = { null }
  ): Graph = this.copy(
    query = query + "($alias:${concatenate(labels)}${properties(labels, properties)})",
    aliases = aliases + (alias to labels.toList())
  )

  /**
   * Builds a Cypher query part for a node definition on the form:
   * (:[labels] { [properties] })
   *
   * @return A [Graph] containing the previously built query and context plus the one generated by
   * this node function.
   */
  fun <T : Node> node(
    vararg labels: T,
    block: T.() -> String? = { null }
  ): Graph {
    return this.copy(
      query = query + "(:${concatenate(labels)}${properties(labels, block)})"
    )
  }

  /**
   * Builds a Cypher query part for a node definition on the form:
   * ([alias] { [properties] })
   *
   * @return A [Graph] containing the previously built query and context plus the one generated by
   * this node function.
   */
  fun node(
    alias: String = "",
    block: () -> String? = { null }
  ): Graph {
    return this.copy(
      query = query + "($alias${properties(block)})",
      aliases = aliases + (alias to emptyList())
    )
  }

  /**
   * Builds a Cypher query part for a relationship definition on the form:
   * ([alias] { [properties] })
   *
   * @return A [Graph] containing the previously built query and context plus the one generated by
   * this [relationship] function.
   */
  fun relationship(
    alias: String = "",
    block: () -> String? = { null }
  ): Graph {
    return this.copy(
      query = query + "-[$alias${properties(block)}]->",
      aliases = aliases + (alias to emptyList())
    )
  }

  /**
   * Builds a Cypher query part for a relationship definition on the form:
   * -[[alias]:[types] { [properties] }]->
   *
   * @return A [Graph] containing the previously built query and context plus the one generated by
   * this [relationship] function.
   */
  fun <T : Relationship> relationship(
    alias: String = "",
    vararg types: T,
    block: T.() -> String? = { null }
  ): Graph = this.copy(
    query = query + "-[$alias:${concatenate(types)}${properties(types, block)}]->",
    aliases = aliases + (alias to types.toList())
  )

  /**
   * Builds a Cypher query part for a relationship definition on the form:
   * -[:[types] { [properties] }]->
   *
   * @return A [Graph] containing the previously built query and context plus the one generated by
   * this function.
   */
  fun <T : Relationship> relationship(
    vararg types: T,
    block: T.() -> String? = { null }
  ): Graph {
    return this.copy(
      query = query + "-[:${concatenate(types)}${properties(types, block)}]->"
    )
  }

  private fun <T : Node> concatenate(labels: Array<out T>) = labels.map(Node::label).joinToString(":")

  private fun <T : Relationship> concatenate(types: Array<out T>) = types.map(Relationship::type).joinToString("|")

  private fun properties(block: () -> String?): String = block().body()

  private fun <T : Entity> properties(entities: Array<out T>, block: T.() -> String?) =
    entities.first().block().body()

  private fun String?.body(): String = this?.let { " { $it }" } ?: ""
}